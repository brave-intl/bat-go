package vault

import (
	"encoding/hex"
	"errors"
	"fmt"
	"strings"

	"github.com/brave-intl/bat-go/cmd"
	"github.com/brave-intl/bat-go/utils/vaultsigner"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	keysList = []string{
		"uphold-contribution",
		"uphold-referral",
		"gemini-contribution",
		"gemini-referral",
	}

	// ImportKeyCmd imports keys to be used in vault
	ImportKeyCmd = &cobra.Command{
		Use:   "import-key",
		Short: "import keys to be used in vault",
		Run:   cmd.Perform("import key", ImportKey),
	}
)

func init() {
	VaultCmd.AddCommand(
		ImportKeyCmd,
	)
	// wallet-refs - default to keysList above. list of known keys
	// under which new wallet secrets can be referenced
	ImportKeyCmd.PersistentFlags().StringSlice("wallet-refs", keysList,
		"the default path to a configuration file")
	cmd.Must(viper.BindPFlag("wallet-refs", ImportKeyCmd.PersistentFlags().Lookup("wallet-refs")))

	// ed25519-private-key
	ImportKeyCmd.PersistentFlags().String("ed25519-private-key", "",
		"ed25519-private-key the existing json schema files")
	cmd.Must(viper.BindPFlag("ed25519-private-key", ImportKeyCmd.PersistentFlags().Lookup("ed25519-private-key")))
	cmd.Must(viper.BindEnv("ed25519-private-key", "ED25519_PRIVATE_KEY"))

	// ed25519-public-key
	ImportKeyCmd.PersistentFlags().String("ed25519-public-key", "",
		"ed25519-public-key the existing json schema files")
	cmd.Must(viper.BindPFlag("ed25519-public-key", ImportKeyCmd.PersistentFlags().Lookup("ed25519-public-key")))
	cmd.Must(viper.BindEnv("ed25519-public-key", "ED25519_PUBLIC_KEY"))

	// uphold-provider-id
	ImportKeyCmd.PersistentFlags().String("uphold-provider-id", "",
		"uphold-provider-id the existing json schema files")
	cmd.Must(viper.BindPFlag("uphold-provider-id", ImportKeyCmd.PersistentFlags().Lookup("uphold-provider-id")))
	cmd.Must(viper.BindEnv("uphold-provider-id", "UPHOLD_PROVIDER_ID"))

	// gemini-client-id
	ImportKeyCmd.PersistentFlags().String("gemini-client-id", "",
		"gemini-client-id is the client id corresponding to the oauth app that users authenticated against")
	cmd.Must(viper.BindPFlag("gemini-client-id", ImportKeyCmd.PersistentFlags().Lookup("gemini-client-id")))
	cmd.Must(viper.BindEnv("gemini-client-id", "GEMINI_CLIENT_ID"))

	// gemini-client-key
	ImportKeyCmd.PersistentFlags().String("gemini-client-key", "",
		"gemini-client-key is the client key generated by and submitted for gemini requests")
	cmd.Must(viper.BindPFlag("gemini-client-key", ImportKeyCmd.PersistentFlags().Lookup("gemini-client-key")))
	cmd.Must(viper.BindEnv("gemini-client-key", "GEMINI_CLIENT_KEY"))

	// gemini-client-secret
	ImportKeyCmd.PersistentFlags().String("gemini-client-secret", "",
		"gemini-client-secret the hmac to create a checksum with")
	cmd.Must(viper.BindPFlag("gemini-client-secret", ImportKeyCmd.PersistentFlags().Lookup("gemini-client-secret")))
	cmd.Must(viper.BindEnv("gemini-client-secret", "GEMINI_CLIENT_SECRET"))
}

// ImportKey pulls in keys from environment variables
func ImportKey(command *cobra.Command, args []string) error {
	var err error

	ReadConfig(command)
	walletRefs := viper.GetStringSlice("wallet-refs")
	ed25519PrivateKey := viper.GetString("ed25519-private-key")
	ed25519PublicKey := viper.GetString("ed25519-public-key")
	upholdProviderID := viper.GetString("uphold-provider-id")
	geminiClientID := viper.GetString("gemini-client-id")
	geminiClientKey := viper.GetString("gemini-client-key")
	geminiClientSecret := viper.GetString("gemini-client-secret")

	wrappedClient, err := vaultsigner.Connect()
	if err != nil {
		return err
	}

	for _, key := range walletRefs {
		parts := strings.Split(key, "-")
		switch parts[0] {
		case "uphold":
			if len(ed25519PrivateKey) != 0 && len(ed25519PublicKey) != 0 {
				err = upholdVaultImportKey(
					wrappedClient,
					Config.GetWalletKey(key),
					ed25519PrivateKey,
					ed25519PublicKey,
					upholdProviderID,
				)
				if err != nil {
					return err
				}
			}
		case "gemini":
			if len(geminiClientSecret) != 0 {
				err = geminiVaultImportValues(
					wrappedClient,
					Config.GetWalletKey(key),
					geminiClientID,
					geminiClientKey,
					geminiClientSecret,
				)
				if err != nil {
					return err
				}
			}
		default:
			return errors.New("did not recognize option: " + key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func upholdVaultImportKey(
	wrappedClient *vaultsigner.WrappedClient,
	importName string,
	ed25519PrivateKey string,
	ed25519PublicKey string,
	upholdProviderID string,
) error {
	privKey, err := hex.DecodeString(ed25519PrivateKey)
	if err != nil {
		return errors.New("ERROR: Key material must be passed as hex")
	}

	pubKey, err := hex.DecodeString(ed25519PublicKey)
	if err != nil {
		return errors.New("ERROR: Key material must be passed as hex")
	}

	cmd.Must(wrappedClient.GenerateMounts())
	fmt.Printf("importing secret for %s\n\tof public length: %d\n\tand private length: %d\n", importName, len(pubKey), len(privKey))
	_, err = wrappedClient.FromKeypair(privKey, pubKey, importName)
	if err != nil {
		return err
	}
	_, err = wrappedClient.Client.Logical().Write("wallets/"+importName, map[string]interface{}{
		"providerId": upholdProviderID,
	})
	return err
}

func geminiVaultImportValues(
	wrappedClient *vaultsigner.WrappedClient,
	importName string,
	geminiClientID string,
	geminiClientKey string,
	geminiClientSecret string,
) error {
	cmd.Must(wrappedClient.GenerateMounts())
	fmt.Printf("importing secret for %s\n\tof length: %d\n", importName, len(geminiClientSecret))
	_, err := wrappedClient.ImportHmacSecret([]byte(geminiClientSecret), importName)
	if err != nil {
		return err
	}
	_, err = wrappedClient.Client.Logical().Write("wallets/"+importName, map[string]interface{}{
		"clientid":  geminiClientID,
		"clientkey": geminiClientKey,
	})
	return err
}
